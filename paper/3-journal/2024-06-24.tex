\chapter{2024-06-24} % (fold)
\label{chap:2024-06-24}
07:50
\begin{table}
  \caption{Schedule}\label{tab:}
  \begin{center}
    \begin{tabular}[c]{l|l|l}
      \hline
      Day & Morning & Afternoon \\
      \hline
      Monday & Decide on features of my arch & DevOps: hooks and dut/testing infra, tex macro journal \\
      Tuesday & Testing Architecture, Chapter on mem access, magic addr?, rel acccess, absolute access, call stack, call stack in code & How many Data words?, Mircocode, Assembler \\
      Mittwoch & "Fun" Instrucctions/IS in general & Define (and implement) reqs (thus Testcases) ALU \\
      Thursday & ALU impl & ALU impl (assembler) \\
      Friday & assembler & vcd motion canvas plugin \\
      
      \hline
    \end{tabular}
  \end{center}
\end{table}

General Ideas: Going into this for features
I/O of system. How do I do I/O? Because I need I/O...
\begin{enumerate}
  \item Magic Adresses, so certain memory is I/O buffers?
  \item I/O registers? Buffering is going to be annoying. I need interrupts then?
  \item iface with py so it looks cool/fun? thats also always a factor? 
\end{enumerate}

Microcode. 
Distributing the microcode w/ each assembly. 
"Only the instructions you need". 
Also prematurely being able to "break" out of state cycles prematurely. one more flag in the control word required, if that high, skip to next instruction. 
--> Saves instruction cycles. 

That probably even means that you should be able to modify microcode on the fly. Sounds sketchy. 


"Unlimited" Memory -> In silicon, goal is to only need to add one adder/subtracter. 
With "unlimited memory address width", that means, I would need relative addressing, if I cant access absolute. 

Also still first 255 addr would still be accsible absolutely?

What would I do with magic addresses if I want them. Sacrifice first 255 for them?

Other Idea: In Microcode implemntation of what part of memory to access. 

But Microcode in mem would be annoying? every instr/state and resulting control word would have to travel over the bus. Sounds annoying. 

What if secondary ROM for microcode only. Like I think Ben Eater does in his SAP-1/2/3 impl.
Would loose the ability to change microcode on the fly with that however. 

obv in this case, all ROMs/RAMs in this case are just files


Ideas on Testing Infrastructure:

Problem is this has to be "recursive testing in a way". 

Each sub component would probably have its own testcases. And thus would have to be built one after the other, tested, next level built, tested. 

Each test may have different test harnesses but some may have the same test harness but different input (assemblies). 


There are libs/tools out there that do unit testing. Although it seems like they wouldnt be able to do multiple passes with different assemblies. https://github.com/dpretet/svut https://github.com/VUnit/VUnit

VUnit seems more promising, as API more scriptable, but apparently no specific integration to iverilog.

Goal finally would be to run tests on GLab runners. 


\dirtree{%
.1 /.
.2 computer.v.
.2 alu. 
.3 alu.v. 
.3 alu-subcomponent. 
.4 alu-subcomponent.v. 
.4 test. 
.5 alu-subcomp-case-1-tb.v.
.5 alu-subcomp-case-1.test.py.
.5 alu-subcomp-case-2-tb.v.
.5 alu-subcomp-case-2.test.py.
.5 alu-subcomp-case-2.dat.
.3 test.
.4 alu-case-1-tb.v.
.4 alu-case-1.test.py.
.2 test.
.3 computer-test-1-tb.v.
.3 computer-test-1.test.py.
.3 computer-t-1-c-1.asm.
.3 computer-t-1-c-2.asm.
}

Apart from that would probably also be nice if CICD compiles tex paper. not must have




Ideas on Chapter Structure:



% chapter 2024-06-24 (end)
