\section{Implementation}



The implementation of the simulation is done in the hardware description language Verilog. The architecture shall be implemented in indivdual modules, each module being tested individually.    

Considering the schematic \ref{fig:vna-adapted} all modules will have control signals and a connection to the bus as their ports.  

\subsection{Timing}
Neither is the timing governed by any leading principles nor does it have a direct impact on the architecture or its performance. It must be established nonetheless to ensure that the computer is able to function properly.

The clock signal, an equally spaced pulse where $t_{high} = t_{low}$, is the only timing signal required. Given signals from the control unit modules shall latch data onto the bus at the rising edge of the clock signal, and the data shall be read at the falling edge.



\subsection{Arithmetic Logic Unit}
Considering all requirements the ALU must perform at a rising edge of the clock given a control signal an operation. 


There are two options for the ALU recieving the control signal indicating which operation to perform. Either each operation is represented by a single control signal or each operation is assigned a binary representation and then decoded in the ALU. The first approach would conform more to the VNA as all decoding would be performed in the control Unit, where as with the second approach, the instruction would only fully be decoded in the ALU. The second approach is however much more efficient and readable. The first approach would require a 10 bit control signal whereas the second approach would only require $ceil(\log_2 10) = 4$ bits. Additionally the operations could be represented easily as an enumeration in Verilog ensuring readability. The second option was implemented. 

The two registers A and B are connected to the ALU directly. The alu is connected to the bus as an output. 

\begin{table}[H]
\begin{tabular}{cccc}
  Type& Name & Purpose & \texttt{name}\\ \hline
  I   & Clock & Timing & \texttt{clock}\\
  O   & Bus     & Data output & \texttt{out}        \\
  I   & Register A and B & Data input & \texttt{register1} and \texttt{register2} \\
  I   & ALU control word & Control & \texttt{alu\_op\_e}\\
O   & Flag word & Control & \texttt{alu\_flag\_e}
\end{tabular}
\caption{}
\label{tab:alu-i/o}
\end{table}

Given the netlist all test cases can be implemented. The implementation is straightforward for all requirements specifying an arithmetic or logic operation. Two arbitrary values are loaded into the registers and the correct control signals are sent to the ALU the clock cycled and then checked if the output is correct. The same applies to the tests for flag generation. The test case for Feat. Req. \ref{req:alu-no-output} is implemented by assigning arbitrary values and performing an operation without however enabling the output signal, finally checking if any content was latched onto the bus.  

The body of the module is based around a single \texttt{always\_ff} block, as the ALU only latches onto the bus, the block is \texttt{\@posedge}.

As the ALU only every outputs directly to the bus any operation is performed at the rising edge only one block is required. In the \texttt{always\_ff}-block a switch case exectues the correct operation based on \texttt{alu\_flag\_e}. The zero flag is generated by a continous assignment. The carry flag is generated by left padding the addition by one bit, removing the padding before latching the content onto the bus. The flags are latched into a register whenever an operation is performed, such that they are presistent until the next operation.


% \lstinputlisting[language=verilog]{../computer/src/modules/alu.sv}

\subsection{Memory}

Following the principle of the ALU the memorys op code is an enum. Apart from the control signal for the operation, the operations require additional control signals. All operations, except for absolute memory access requires an indication of which address register, PC or MAR, to use. The read operation additionally requires the indication for the data word. The bus is connected as input and output. From this a netlist can be created.

\begin{table}[H]
\begin{tabular}{cccc}
 Type & Name               & Datatype                       & name                          \\
 I    & Bus input          & \texttt{bit{[}7:0{]}}          & \texttt{input}                \\
 O    & Bus output         & \texttt{bit{[}7:0{]}}          & \texttt{output}               \\
 I    & Operation          & \texttt{memory\_op\_e}         & \texttt{op}                   \\
 I    & Data Word Selector & \texttt{bit}                   & \texttt{data\_word\_selector} \\
 I    & Bus Selector       & \texttt{address\_register\_selector\_e} & \texttt{address\_register\_selector}        \\
 I    & Clock              & \texttt{bit}                   & \texttt{clock}               
 \end{tabular}
 \caption{}
 \label{tab:memory-io}
\end{table}

The test cases for the memory module are implemented similarly to those for the ALU. For all tests, involving read operations, a value is stored directly into the array that represents the physical memory cells in the simulation and then the correct address is either loaded directly (absolute reads) or is the result of several operations (relative reads) where the address must first be calculated. For write operations the address is also either loaded directly or composed of multiple operations. The value that is to be wrriten is written onto the bus and the write operation is performed. The array is then checked at the address to see if the value is correctly written.

The read and write operations are implemented by reading/writing to an array with the index being the selected address register with the data word selector being appended as the least significant bit. The selected address bus is generated by a continous assignment based on the control signal. 

Read operations are performed on the rising edge of the clock signal. When specified, the value from the memory cells at the address specified by the selected bus and data word selector is assigned to the output. Write operations are performed on the falling edge of the clock signal. When specified, the value on the input bus is written to the memory cells at the address specified by the selected bus and data word selector. They are thus executed in to seperate \texttt{always\_ff} blocks.

As continous assignments are used for the selected address bus, operations on the address registers cannot be done on the selected address bus variable. Instead the address registers are modified directly with an \texttt{if} statement.


