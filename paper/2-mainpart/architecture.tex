\section{Architecture}

Following the Von Neumann the architecture shall be structured in a number of modules, the arithmetic logic unit (ALU), the control unit (CU), memory, input and output. The modules interact with each over the three buses, sharing data, address and control signals. All actions are orchestrated by the control unit, signalling the other modules when to read or write data, when to perform calculations, and when to output data, based on the microinstructions stored in the control unit.

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{figures/VNA}
  \end{center}
  \caption{The Von Neumann Architecture \cite{fig-vna}}\label{fig:vna}
\end{figure}

A microinstruction is typically referring to the state of all control signals and is typically generated by the microcode. As it would be extremely inefficient, due to repetition, to only program a computer with individual control signals, the control signals are grouped into microinstructions. The microinstructions are then generated by a net of logic gates or a storage depending on the macro instruction and the current state of the computer.

The pioneering approach of the Von-Neumann-Architecture however was to store the instructions in the same physical memory as the data which simplified the programming process by allowing other programs (compilers, interpreters) to translate from more abstract languages. As instructions and data are stored in the same memory, they must also share the same physical bus. This however leads  to a phenomenon known as the \textit{von Neumann bottleneck} \cite{cit.needed}, where the bus and memory are the limiting factor in the speed of the computer. 

The \textit{von Neumann bottleneck} arises because both the instruction fetch and all data operations must share the same bus and can only occur one after the other, creating a point of congestion. When taking into account that (random access) memory retrieval takes significantly longer than any other operation this bottleneck can be alleviated by introducing a secondary form of memory. Deviating from the Von-Neumann-Architecture the memory module shall be split up into to two modules, a random access memory, storing data and instructions referenced by addresses and the registers, storing a single bus width of data. As well as a number of registers, storing operand data for the alu. The registers function without an address and are directly operated by the control unit.

The modules, in which this architecture is split up to, thus are the ALU, the CU, the memory, the register and the input and output. 

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{figures/VNA-Adapted}
  \end{center}
  \caption{The Von Neumann Architecture \cite{fig-vna}}\label{fig:vna-adapted}
\end{figure}

The combined address and data bus is from here on out refered to as the bus.


\iffalse
\begin{figure}[H]
  \begin{center}
  \begin{tikzpicture}[
      node distance=2cm,
      every node/.style={circle, draw, minimum size=1.5cm, align=center},
      ->, >=stealth, thick
  ]

  % Nodes arranged in a circular pattern
  \node (fetch) at (90:2.5cm) {Fetch};
  \node (decode) at (210:2.5cm) {Decode};
  \node (execute) at (330:2.5cm) {Execute};

  % Arrows connecting nodes
  \draw[->] (fetch) -- (decode);
  \draw[->] (decode) -- (execute);
  \draw[->] (execute) -- (fetch);

  \end{tikzpicture}
  \end{center}
  \caption{The fetch-decode-execute cycle \cite{chatgpt}}\label{fig:fde}
\end{figure}
\fi



\input{2-mainpart/architecture/alu}

\input{2-mainpart/architecture/memory}

\input{2-mainpart/architecture/register}

\input{2-mainpart/architecture/control_unit}

\input{2-mainpart/architecture/input_output}
