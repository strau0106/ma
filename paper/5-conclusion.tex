\chapter{Conclusion} \label{chap:conclusion}
This chapter concludes this project by first evaluating the product and process based on the goals defined in \ref{sec:goals}.

\section{Evaluation}
The most important requirement to me, of having an 8-bit bus width is complied with, all data, be it operands or addresses always travels over 8-bit at some point. The requirement of Turing equivalence to a Turing machine was demonstrated successfully, by demonstrating the ability to perform Brainfuck. Which is. 

Implementation of the von Neumann Architecture was done on best effort basis. Naming schemes and the applied modularization adhere to it. Deviations from it occured by introducing registers. The extended memory bus width is not considered to be one, as the von Neumann doesn't specify that they need to be the same bus, but only, that they are stored in same memory, which in return also means same bus, kinda.

The focus on simplicity during development

The requirements of the possibility graphic explanation, given the aforementioned supporting work, is only to be done for a presentation.


The test report shows a coverage of 98.5\% of the 137 lines of code \ref{lst:build}, in fact only two lines are not reported to be not covered. The two lines are a port definition and a line concerning macro instruction decoding. Interesting enough, these lines of code are not explicitly covered by any requirements. The only requirement defining it, is \ref{req:cw-from-instr}. It only states, that control word must be generated from flags. The implementation now however also implements a register to store the current macro instruction, such that the instruction can be decoded over several steps. 

This coincides with the errors that were discovered and rectified in sections \ref{sec:timing-issues} through \ref{sec:flag-latching}. These problems all can be traced back to the first design steps, where either a requirement was not broken down enough or the exact behavior was never specified. This is confirmed by the fact that before programming for \ref{chap:demo} the entire test suite for individual components passed.

\section{Reflection}
This inevitably leads to the insight that the process of low level requirement definition failed. Early in the process, after defining the feature set, I was under the impression that the architectures' logic design was sufficiently specified. After development this was confirmed by test reports showing near full coverage, indicating that the requirements should theoretically be "good" enough.

In hindsight, further specification especially towards timing, and interaction between the modules, should have been performed.

Furthermore, the reliance on test coverage reports, to judge the level of specification, was suboptimal. Functional tests of functional and feature requirements will produce high test coverage. 

In essence, way more architectural requirements should have been defined.

The return on time invested into development operations was limited 

\section{Comparison}

    - Compare to 8-bit eater and SAP-1/SAP-2/SAP-3
    Comparison based on feature set would only make sense when also comparing complexity. This is difficult, no systemverilog counterparts exist. 

    What can be compared however is useability. 
    This architecture usability physically would be limited, as all results would be directly in memory, and one cannot easily access them.

    Generally however none of these comparable architectures to have any sort of usage opportunities.


\section{What's next}

