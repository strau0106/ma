\chapter{Introduction}

\section{Idea and Goal}
- Idea: Computer cool, nostalgic. 

The goal of this project is to: 
\begin{itemize}
  \item Have a functioning computer architecture that:
 \begin{enumerate}
    \item Has an 8-bit bus width; and
    \item Is Turing complete; and
    \item Is based on the Von-Neumann-Architecture (VNA); and
    \item Implements the Von-Neumann-Cycle; and
    \item Implements features wanted by me; and  
    \item Is kept as simple as possible; and
    \item Is, with supporting work, explainable graphically.
  \end{enumerate}
  \item Have a simulation of this computer architecture that: 
  \begin{enumerate}
    \item Is fully tested; and
    \item Is kept as simple as possible; and
    \item Can be interacted with by a user; and
    \item Is programmable by a higher level language (assembly); and
    \item Is, with supporting work, explainable graphically.
  \end{enumerate}
\end{itemize}

Whilst this paper functions as a process documentation with the secondary function of explaining the architecture reasonably.
  
Additionally, the development of the computer architecture shall occur in requirement and test driven manner. 

\section{Theory}
Test driven development, unit testing, reproducibility, testing is important ;) no chance to produce working silicon otherwise.

\section{Tools}
With the development of highly complex chip designs further and further abstraction of the process was required. Whilst the earliest chip designs were drawn by hand and transferred onto silicon by photolithography, chip designs nowadays are written in an abstract computer language; a "Hardware Description Language". Apart from allowing separation, modularity and reusability of components, this description allows for simulation of the design and thus reduces errors in the final, on silicon, design 

The most popular flavor of such an "HDL" is Verilog, as defined in \cite{10458102} and its extensions. Given widespread professional use of Verilog, more specifically a Verilog superset "SystemVerilog", I deem it the best option for this project, allowing me to rely on a large amount of information and guides on the topic. The terms "SystemVerilog" and "Verilog" will be used interchangeably. 

As \cite{10458102} only defines the language's syntax, a Verilog tool suite is required. The pool to choose from is once again CHANGE large. Although I have previous in using Verilog, my expertise on the intricacies on Verilog simulation is still limited. I opted to choose my simulation and/or emulation tool suite based on its integration with other tooling.

Finally, I chose the Verilator suite. Its key feature is the compilation of the Verilog code to a binary and the 
generation of an interface to C++. Apart from being able to rely on previous experience in C++, it also allows me to make use of a vast ecosystem of testing, code coverage and DevOps frameworks. I chose the GoogleTest framework for my unit testing. 

I use Git and GitLab due to previous experience and existing infrastructure. 
  
\section{Development Environment}
To reproduce the development environment for this work, the following packages need to be installed with the system package manager. It is suggested to use the GNU+Linux operating system. 

\begin{itemize}
  \item verilator@5.24
  \item a C++ toolchain (e.g. gcc)
  \item cmake
  \item ninja
\end{itemize}
  

Finally, git hooks are set up to ensure that before comitting, all compilation steps complete and the commit message format complies with the conventional commit standard \cite{conventionalcommit}

\section{Development Operations (DevOps)}
Additionally, to increase development velocity and traceability development operations (DevOps) were put intro place. 

The aim of DevOps, short for developer operations, is to shorten a development life cycle, by firstly providing fast feedback to developers on code (unit testing, static code analysis) and secondly continuous deployment of the product. 


The following shall be continuously run whenever a change is committed:  

\begin{itemize}
  \item Compilation of all code and of the paper.  
  \item Execution of all test cases and logging of the results to the DevOps platform (GitLab CI)
  \item Code coverage report generation
\end{itemize}

To do so I leveraged my version control system (git) and the GitLab CI/CD platform. Replicating the local environments, I wrote two Debian based docker containers \cite{dockerVerilator} \cite{dockerLatex} to be used in the respective pipelines. One for compilation of the architecture and one for the compilation of the paper. The pipelines are set up to report code coverage and test results to the version control system (GitLab). 

As the version control system infrastructure does not provide any infrastructure to execute these pipelines, e.g. servers to run the docker containers, own infrastructure was put into place to do this.

\subsection{Requirements}
Given the previously defined goals three distinct groups of feature requirements to the computer architecture can be differentiated: 

Requirements resulting from the need for Turing completeness \cite{turing1936a}, from here on out referred to as "Turing requirements", are based around the following concepts: increasable memory (thus infinite), ability to modify memory and the ability to execute conditionally. 

"Architectural requirements" are a set of non-functional requirements given by the intended computer architecture \cite{vonneuman1945a}. They are by design only verifiable and not testable. 

Finally, "feature requirements" are requirements defined by me to expand the feature set. These requirements shall be justified, when put in place. 

\newtheorem{turing-requirement}{Turing Req.}[subsection]
\newtheorem{arch-requirement}{Arch. Req.}[subsection]
\newtheorem{feat-requirement}{Feat. Req.}[subsection]

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in the requirements are to be interpreted as described in RFC 2119.

\subsection{Unit Testing}
- Code coverage
- Tests



- 8 bit -> limitation on complexity
- Nostalgic
- Still a lot of (fun things) that can be implemented even only with 8-bit bus width
- Turing Complete and aligned with John von Neumann.



