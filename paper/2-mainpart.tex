\chapter{The Computer} % (fold)
\label{chap:The Computer}

\section{The Goal}

- 8 bit -> limitation on complexity
- Nostalgic
- Still a lot of (fun things) that can be implemented even only with 8-bit bus width
- Turing Complete and aligned with John von Neumann.


\section{Process}
How to get to the Goal?

I have decided to opt for a requirement driven, test based development approach. Thus the current plan for the development is the following:
\begin{enumerate}
  \item Define loose architecture. (Done, at least in my head)
  \item For each component of the architecture define (testable) requirements. 
  \item (Justify requirements) Unsure wether or not i need to do this.
  \item For each component:
  \begin{itemize}
    \item Write testcases
    \item Write corresponding verilog code.
  \end{itemize}
  \item Write requirements for microcode. (Macro instructions to micro instructions) 
  \item Testcases for requirements. 
  \item Connect all components up.
  \item Test components.
  \item Do fun things, connect to motion canvas, give it a screen, make it run on an FPGA.
\end{enumerate}

Last step is optional, basically applications of the archtitecture, basically using it for fun things. 


\subsection{Requirements}
The requirements can be loosely split into three categories:

\begin{itemize}
  \item Turing requirements
  \item Architechtural requirements
  \item Feature requirements
\end{itemize}


\newtheorem{turing-requirement}{Turing Req.}[subsection]
The implementation of Turing requirements is required to achieve turing completeness. Thus these requirements will always be derived from (probably need a citation here) (Alan Turing, 1936?): 
\begin{itemize}
  \item Infinite memory
  \item Ability to modify memory
  \item Ability to conditionally execute
\end{itemize}

\newtheorem{arch-requirement}{Arch. Req.}[subsection]
Architecturally required are conecpts that must be implemented to create interoperability between the components. They are required to be implemented under every circumstance given a certrain architecture. (I guess most of them are JvNeumann)

\newtheorem{feat-requirement}{Feat. Req.}[subsection]
Feature Requirements: For now, they exist because I want them because they are cool or something like that.


Generally only feature and turing requirements are considered to be tesatable. The fulfillment of the others is inherent to any functioning of the architecture at all. 

\subsection{Tooling}

The choice for the hardware description language fell on Verilog due to its widespread professional use. More specfically this project will use a Verilog superset, SystemVerilog, as it eases development by providing features such as multi-dimensional arrays and structs. 

As Verilog is only a set of syntax, additional software is required to do anything (change here). In my case one of these additionally required pieces of software is a simulator, to let the written Verilog code produce results. Although I have previous experience with a Verilog compilation and simulation suite, Icarus Verilog, I chose another one. The Verilator suite offers a very modern toolset consisting of a compiler/simulator that provides an interface to C++, language diagnostic tools as well as test coverage report generation. I am under the impression that the ability to write test bench code in another language is of great importance as this reduces development time of tests, especially if these tests are more complex, e.g. execution of transpiled assembly code. 

To increase test repeatability and efficiency I have decided to employ a testing framework. Widely used and already used for me, I opted for the GoogleTest framework. It is simple to use and provides testingreports in various formats, e.g. understandable by GitLab. 

To increase initial development momentum I additionally copied build system setup from a third party.


- I chose google test, there are code examples out there with Verilog/Verilator. 
- Copied make files to get started, BSD license so that is fine. 
- latexmk, previous experience, just works.
- neovim, pervious experience, editor i am fastest in
- debian, because linux is great. 


\subsection{Development Operations (DevOps)}
The aim of so called DevOps, short for Developer Operations, is to shorten a development life cycle, by firstly providing fast feedback to developers on code (unit testing, static code analysis) and secondly continous deployment of the product.  

For the development of my computer architecture I have decided to implement such development operations, to speed up the development process and give consistency. 

- my own gitlab ci runner
- Paper TeX. Docker Image derived from leplusorg/docker-latex for my citation style etc, so newest version is always available, also when i am on the go. 
- verilator\_coverage and googletest to lcov and junit reports for gitlab. 
- git\_hooks, so i dont commit things that do not work by accident. 
- gitlab\_ci\_local for testing pipelines. 
- weird gitlab issue with submodules (googletest) not being cleared properly. 

\subsection{All Troubles with tools. title subject to change}
Structing vs alot of signals

Verilator and structs in public, ahhh, alu\_control.h could use that sketchy name there, that doesnt seem to change, but should i?
debian unstable would do, but do i want.

\input{2-mainpart/architecture}







% chapter The Computer (end)
