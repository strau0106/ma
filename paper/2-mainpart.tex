\chapter{The Computer} % (fold)
\label{chap:The Computer}

\section{The Goal}

- Computers complex
- 8 bit -> limitation on complexity
- Nostalgic
- Still a lot of (fun things) that can be implemented even only with 8-bit bus width

\section{Process}
How to get to the Goal?

I have decided to opt for a requirement driven, test based development approach. Thus the current plan for the development is the following:
\begin{enumerate}
  \item Define loose architecture. 
  \item For each component of the architecture define (testable) requirements. 
  \item Justify requirements
  \item For each component:
  \begin{itemize}
    \item Write testcases
    \item Write corresponding verilog code.
  \end{itemize}
  \item Write requirements for microcode. (Macro instructions to micro instructions) 
  \item Testcases for requirements. 
  \item Connect all components up.
  \item Test components.
  \item Do fun things, connect to motion canvas, give it a screen, make it run on an FPGA.
\end{enumerate}

Last step is optional, basically applications of the archtitecture, basically using it for fun things. 


\subsection{Requirements}
The requirements can be loosely split into three categories:

\begin{itemize}
  \item Turing requirements
  \item Architechtural requirements
  \item Feature requirements
\end{itemize}


\newtheorem{turing-requirement}{Turing Req.}[subsection]
Turing requirements are requirements to the architectures that exist to give it turing completeness. Thus these requirements will always be derived from (probably need a citation here) (Alan Turing, 1936?): 
\begin{itemize}
  \item Infinite memory
  \item Ability to modify memory
  \item Ability to conditionally execute
\end{itemize}

\newtheorem{arch-requirement}{Arch. Req.}[subsection]
Architecturally required are conecpts that must be implemented to create interoperability between the components. They are required to be implemented under every circumstance given a certrain architecture. (I guess most of them are JvNeumann)

\newtheorem{feat-requirement}{Feat. Req.}[subsection]
Feature Requirements: For now, they exist.


Generally only feature and turing requirements are considered to be tesatable. The fulfillment of the others is inherent to any functioning of the architecture at all. 

\subsection{Tooling}
- Initially Icarus verilog because experience
- Now Verilator because nicer and more complexer test benches in cpp, esp in relation with unit testing. 
- Now just need a testing framework
- Most popular are GTest and Catch etc. 
- I chose google test, there are code examples out there with Verilog/Verilator. 
- Copied make files to get started, BSD license so that is fine. 
- latexmk, previous experience, just works.
- neovim, pervious experience, editor i am fastest in
- debian, because linux is great. 


\subsection{Development Operations (DevOps)}
The aim of so called DevOps, short for Developer Operations, is to shorten a development life cycle, by firstly providing fast feedback to developers on code (unit testing, static code analysis) and secondly continous deployment of the product.  

For the development of my computer architecture I have decided to implement such development operations, to speed up the development process and give consistency. 

- my own gitlab ci runner
- Paper TeX. Docker Image derived from leplusorg/docker-latex for my citation style etc, so newest version is always available, also when i am on the go. 
- verilator\_coverage and googletest to lcov and junit reports for gitlab. 
- git\_hooks, so i dont commit things that do not work by accident. 
- gitlab\_ci\_local for testing pipelines. 
- weird gitlab issue with submodules (googletest) not being cleared properly. 

\subsection{All Troubles with tools. title subject to change}
Structing vs alot of signals

Verilator and structs in public, ahhh, could use that sketchy name there, that doesnt seem to change, but should i?


\input{2-mainpart/architecture}







% chapter The Computer (end)
